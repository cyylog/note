##### kafka中设计的名词：

###### 1.消息记录：由一个key，一个value和一个时间戳构成，消息最终存储在主题下的分区中，记录在生产中称为生产者记录，在消费者中称为消费记录。kafka集群保持了所有发布的消息，直到他们过期，无论消息是否被消费了，在一个可配置的时间段内，kafka集群保留了所有发布的消息。比如消息的保存策略被设置为2天，那么在一个消息被发布的两天时间内，它都是可以被消费的。kafka的性能是和数据量无关的常量级的，所以保留太多数据并不是问题。

###### 2.生产者：生产者用于发布消息

###### 3.消费者：消费者用于订阅消息

###### 4.消费者组：相同的groupID的消费者组，每个消费者都需要设置一个组id，每条消息只能被consumer group中的一个Consumer消费，但是可以被多个consumer group消费。

###### 5.主题（topic）：消息的一种逻辑分组，用于对消息分门别类，每一类消息称之为一个主题，相同主题的消息放在一个队列中

######6.分区（partition）：消息的一种物理分组，一个主题被拆成多个分区，没一个分区就是一个顺序的，不可变的消息队列，并且可以持续添加，分区中的每个消息都被分配了一个唯一的id，称之为偏移量（offset），在每个分区中偏移量都是唯一的。每个分区对应一个逻辑log，有多个segment组成。

###### 7.偏移量：分区中每个消息都有一个唯一的id，称之为偏移量，代表已经消费的位置

###### 8.代理（broker）：一台kafka服务器称之为一个broker

###### 9.副本（replica）：副本只是一个分区（partition）的备份。副本不读取或写入数据。他们用于防止数据丢失

###### 10.领导者：leader是负责给定分区的所有读取和写入的节点

###### 11.追随者：跟随领导者指令的节点被称为Follower

###### 12.zookeeper：kafka代理是无状态的，所以它们使用zookeeper来维护它们的集群状态。zookeeper用于管理和协调kafka代理



##### kafka使用场景

kafka的应用很广泛，在这里简单介绍几种

- 服务解耦

  比如我们发了一个帖子，除了写入数据库之外还有很多联动操作，比如给关注这个用户的人发送通知，推送到首页的时间线列表，如果用代码实现的话，发帖服务就要调用通知服务，时间线服务，这样的耦合很大，并且如果增加一个功能依赖发帖，除了要增加新功能外还要修改发帖代码。

  解决方法：引入kafka，将发完贴的消息放入kafka消息队列中，对这个主题感兴趣的功能就自己去消费这个消息，那么发帖功能就能够完全独立。同时即使发帖进程挂了，其他功能还能够使用，这样可以将bug隔离在最小范围内

- 流量削峰

流量削峰在消息队列中也是常用场景，一般在秒杀或团购活动中使用比较广泛。当流量太大的时候达到服务器瓶颈的时候可以将事件放在kafka中，下游服务器当接收到消息的时候自己去消费，有效防止服务器被挤垮

- 消息通讯

消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯中，比如客户端A跟客户端B都使用同一队列进行消息通讯，客户端A，客户端B，客户端N都订阅了同一个主题进行消息发布和接受不了实现类似聊天室效果