### 事务
#### 隔离性与隔离级别
事务的特性（ACID：Atomicity、Consistency、Isolation、Durability），即（原子性、一致性、隔离性、持久性）
```json
* 原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。
* 一致性：数据库总是从一个一致性的状态转换到另外一个一致性的状态。
* 隔离性：通产来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。
* 持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中。
```

##### SQL标准的事务隔离级别：
```json
* 读未提交(read uncommitted)：在read uncommitted级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。
*读提交(read committed)：指一个事务开始时，只能看见已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。

* 可重复读(repeatable read)：repeatable read解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别无法解决幻读（Phantom Read）的问题。所谓脏读，指的是当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。
可重复读是mysql的默认事务隔离级别。
* 串行化(serializable)：serializable是最高的隔离级别。它通过强制事务串行执行，避免了幻读的问题。简单来说，serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。
```

