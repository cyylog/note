

[Toc]



### docker Namespace

```
Cgroup(control Groups)：可以对指定的进程做各种计算机资源的限制，比如限制CPU的使用率，内存使用量，IO设备的流量等等
 * CPU子系统，用来限制一个控制组（一组进程，可以理解为一个容器里的所有进程）可使用的最大CPU。
 * memory子系统，用来限制一个控制组最大的内存使用量。
 * pids子系统，用来限制一个控制组里最多可以运行多少个进程。
 * cpuset子系统，这个子系统用来限制一个控制组里的进程可以在哪几个物理CPU上运行。
```

```json
ipc
network
mount
pid
time
user
uts
```

##### PID Namespace

> 负责隔离不同容器的进程

##### Network Namespace

> 负责管理网络环境的隔离

##### Mount Namespace

> 管理文件系统的隔离 

```
PID
```

##### Namespace和Cgroups的区别

>   Namespace帮助容器来实现各种计算资源的隔离，Cgroups主要限制的是容器能够使用的某种资源量。

容器其实就是Namespace + Cgroups



##### 进程处理信号的三种选择

| --             | --                                               |
| -------------- | ------------------------------------------------ |
| 忽略（Ignore） | 对信号不做任何处理，但 SIGKILL 和 SIGSTOP 例外。 |
|捕获（Catch） | 让用户进程可以注册自己针对这个信号的handler，但 SIGKILL 和 SIGSTOP例外。|
| 缺省（Default） | Linux为每个信号都定义一个缺省的行为。对于大部分的信号，应用程序不需要注册自己的handler，使用系统缺省定义行为即可。 |

> **进程对每种信号的处理，包括上面三个选择：调用系统缺省行为、捕获、忽略。**

```json
第一个选择就是缺省，如果我们在代码中对某个信号，比如SIGTERM信号，不做任何 signal() 相关的系统调用，那么在进程运行的时候，如果接受到信号 SIGTERM，进程就会执行内核中 SIGTERM 信号的缺省代码。

内核中对不同的信号有不同的缺省行为，一般会采用退出（terminate），暂停（stop），忽略（ignore）这三种行为中的一种。
对于 SIGTERM 这个信号来说，它的缺省行为就是进程退出（terminate）。


第二个选择捕获，捕获指的就是我们在代码中为某个信号，调用 signal() 注册自己的handler。这样进程在运行的时候，一旦接受到信号，就不会再去执行内核中的缺省代码，而是会执行通过 signal() 注册的handler。


第三个选择忽略，如果要让进程“忽略”一个信号，我们就要通过 signal() 这个系统调用，为这个信号注册一个特殊的handler，也就是 SIG_IGN.
```

> **SIGKILL 和 SIGSTOP 信号是两个特权信号，它们不可以被捕获和忽略，这个特点也反映在 signal() 上**

Q：怎么解决停止容器的时候，容器内应用程序被强制杀死的问题？

A：**解决的方法就是在容器的init进程中对收到的信号做个转发，发送到容器中的其他子进程，这样容器中的所有进程在停止的时候，都会收到 SIGTERM，而不是 SIGKILL信号了。**






#### docker僵尸进程

##### docker容器控制进程数

> 在一个容器建立之后，创建容器的服务会在 /sys/fs/cgroup/pids 下建立一个子目录，就是一个控制组，控制组里**最关键的一个文件就是pids.max。** 我们可以向这个文件写入数值，而这个值就是这个容器中允许的最大进程数目。


```json
残留的僵尸进程，在容器里仍然占据着进程号资源，很可能会导致新的进程不能运转
```

```json
僵尸进程产生的原因：父进程在创建完子进程之后就不管了，这就是造成子进程变成僵尸进程的原因。需要父进程调用 wait() 或者 waitpid() 系统调用来避免僵尸进程产生。
```

###### 关于僵尸进程

1. 每一个 Linux 进程在退出的时候都会进入一个僵尸状态（EXIT_ZOMBIE);
2. 僵尸进程如果不清理，就会消耗系统中的进程数资源，最坏的情况是导致新的进程无法启动。
3. 僵尸进程一定需要父进程调用 wait() 或者 waitpid() 系统调用来清理，这样是容器中 init 进程必须具备的一个功能。



#### docker cpu


通过 top 命令查看服务器 CPU 情况

![image-20210218205751902](image-20210218205751902.png)

在截图第三行，每一项值的意思分别是：

###### CPU Usage 一览表

| 类型 | 具体含义 |
|--|--|
| us | User，用户态CPU时间，不包括低优先级进程的用户态时间（nice值 1- 19）|
| sys | System，内核态 CPU 时间 |
| ni | Nice，nice值 1-19 的进程用户态 CPU 时间 |
| id | Idle，系统空闲 CPU 时间 |
| wa | Iowait，系统等待 I/O 的 CPU 时间，这个时间不计入进程CPU 时间 |
| hi | Hardware irq，处理硬中断的时间，这个时间不计入进程 CPU 时间 |
| si | Softirq，处理软中断的时间，这个时间不计入进程 CPU 时间 |
| st | Steal，表示同一个宿主机上的其他虚拟机抢走的 CPU 时间 |



转化为用户图为：

![image-20210218210315159](image-20210218210315159.png)

