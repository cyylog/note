```golang
s0 := []int{1,2,3,4,5,6,7,8}
s1 := s0[3:6]
fmt.Printf("The length of s1: %d\n", len(s1))		//3
fmt.Printf("The capacity of s1: %d\n", cap(s1))	//5
fmt.Printf("The value of s1: %d\n", s1)					//4,5,6

** 切片的容量代表了它的底层数组的长度，但这仅限于使用make函数或者切片字面量初始化的情况。 

这里由于s1是通过在s0上施加切片操作得来的，所以s0的底层数组就是s1的底层数组。

又因为，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至底层数组的末尾。

所以，s1的容量就是其底层数组长度8，减去切片表达式的起始索引位置3，即5。


```




### len()

数组的长度

var arr []int

### cap()

数组的最大容量



### append()

向数组添加元素



````go
package "main"

import "fmt"

func main(){
    var s []int
    for i :=0; i < 100;i++{
        printSlice(s)
        s = append(s, 2 * i + 1)
    }
    fmt.Println(s)
}

func printSlice(s []int){
    fmt.Printf("len=%d,cap=%d\n",len(s),cap(s))
}
````

以上输出结果为

````go
len=0,cap=0
。。。
len=98,cap=128
len=99,cap=128
[1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 101 103 105 107 109 111 113 115 117 119 121 123 125 127 129 131 133 135 137 139 141 143 145 147 149 151 153 155 157 159 161 163 165 167 169 171 173 175 177 179 181 183 185 187 189 191 193 195 197 199]

````

###### #从上面结果可以看出append是直接在结果后面添加值

###### #cap最开始的容量是0，当len的长度大于cap的容量时，cap的容量会*2

